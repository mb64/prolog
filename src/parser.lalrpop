use crate::parser::{Tok, Expr, Clause, ReplItem, Span};
use lasso::{Rodeo, Spur};

grammar<'input, 'rodeo>(input: &'input str, rodeo: &'rodeo mut Rodeo, file_id: u32);

extern {
    type Location = usize;
    type Error = ();

    enum Tok<'input> {
        "(" => Tok::LParen,
        ")" => Tok::RParen,
        "[" => Tok::LBracket,
        "]" => Tok::RBracket,
        "|" => Tok::Bar,

        "." => Tok::Period,
        "," => Tok::Comma,
        "?" => Tok::Question,
        ":-" => Tok::Turnstile,

        "\\+" => Tok::WeirdNot,
        "=" => Tok::Equals,
        "\\=" => Tok::NotEquals,
        is => Tok::Is,
        "+" => Tok::Plus,
        "-" => Tok::Minus,
        "*" => Tok::Times,
        "/" => Tok::Divide,

        "_" => Tok::Wildcard,
        functor => Tok::Functor(<&'input str>),
        Variable => Tok::Variable(<&'input str>),
        number => Tok::Number(<i64>),
    }
}

pub Program: Vec<Clause> = Clause*;
pub ReplItem: ReplItem = {
    <Clause*> => ReplItem::Clauses(<>),
    <Question> => ReplItem::Question(<>),
}

Question = <Expr> "?";

Clause: Clause = {
    <l:@L> <f:Functor> "." <r:@R> => {
        let span = Span::new(file_id, l, r);
        let (_, functor, args) = f;
        Clause { span, functor, args, conditions: vec![] }
    },
    <l:@L> <f:Functor> ":-" <conditions:Exprs> "." <r:@R> => {
        let span = Span::new(file_id, l, r);
        let (_, functor, args) = f;
        Clause { span, functor, args, conditions }
    },
}

// Allow trailing commas bc why not
Exprs: Vec<Expr> = {
    <h:(<Expr> ",")*> <t:Expr?> =>
        h.into_iter().chain(t).collect()
}

Expr: Expr = {
    EqExpr,
    <l:@L> "\\+" <e:Expr> <r:@R> => Expr::Functor {
        span: Span::new(file_id, l, r),
        name: rodeo.get_or_intern("\\+"),
        args: vec![e],
    }
}

Operator<Left,Op,Right>: Expr = {
    Right,
    <l:@L> <lhs:Left> <op:Op> <rhs:Right> <r:@R> => Expr::Functor {
        span: Span::new(file_id, l, r),
        name: rodeo.get_or_intern(op),
        args: vec![lhs, rhs],
    },
}

EqExpr  = Operator<AddExpr, EqOp,  AddExpr>;
AddExpr = Operator<AddExpr, AddOp, UnaryExpr>;
UnaryExpr = {
    MulExpr,
    <l:@L> <op:AddOp> <e:UnaryExpr> <r:@R> => Expr::Functor {
        span: Span::new(file_id, l, r),
        name: rodeo.get_or_intern(op),
        args: vec![e],
    },
}
MulExpr = Operator<MulExpr, MulOp, Term>;

Term: Expr = {
    "(" <Expr> ")",
    <l:@L> "_" <r:@R> => {
        let span = Span::new(file_id, l, r);
        Expr::Wildcard { span }
    },
    <l:@L> <value:number> <r:@R> => {
        let span = Span::new(file_id, l, r);
        Expr::Number { span, value }
    },
    <l:@L> <v:Variable> <r:@R> => {
        let span = Span::new(file_id, l, r);
        Expr::Var { span, name: rodeo.get_or_intern(v) }
    },
    Functor => {
        let (span, name, args) = <>;
        Expr::Functor { span, name, args }
    },
    List,
}

List: Expr = {
    <l:@L> "[" <es:Exprs> "]" <r:@R> => {
        let span = Span::new(file_id, l, r);
        es.into_iter().rev().fold(
            Expr::nil(span, rodeo),
            |tail, head| Expr::cons(head, tail, span, rodeo),
        )
    },

    <l:@L> "[" <es:Exprs> "|" <t:Expr> "]" <r:@R> => {
        let span = Span::new(file_id, l, r);
        es.into_iter().rev().fold(
            t,
            |tail, head| Expr::cons(head, tail, span, rodeo),
        )
    },
}

Functor: (Span, Spur, Vec<Expr>) = {
    <l:@L> <f:functor> "(" <args:Exprs> ")" <r:@R> => {
        let span = Span::new(file_id, l, r);
        (span, rodeo.get_or_intern(f), args)
    },
    <l:@L> <f:functor> <r:@R> => {
        let span = Span::new(file_id, l, r);
        (span, rodeo.get_or_intern(f), vec![])
    },
}


// Operators

EqOp: &'static str = {
    "=" => "'='",
    "\\=" => "'\\='",
    is => "is",
}

AddOp: &'static str = {
    "+" => "'+'",
    "-" => "'-'",
}

MulOp: &'static str = {
    "*" => "'*'",
    "/" => "'/'",
}
